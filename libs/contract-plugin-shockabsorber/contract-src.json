{"code":"/// @title ShockAbsorber - smooth market movements\n/// @author Stephen Taylor\n/// @notice Smooths out the ups & downs of market movement.\n/// Each year reserves the first maxCushionUp percent of profit,\n/// and when the market drops it ensures the user does not lose any principal\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport '@thecointech/contract-oracle/contracts/OracleClient.sol';\nimport '@thecointech/contract-plugins/contracts/BasePlugin.sol';\nimport '@thecointech/contract-plugins/contracts/permissions.sol';\nimport '@thecointech/contract-plugins/contracts/IPluggable.sol';\n\n// import \"hardhat/console.sol\";\n\n// This could definitely be optimized...\nstruct UserCushion {\n  // CostBasis + the profit over time becomes protected\n  int fiatPrincipal;\n\n  // How `coin` is currently adjusted (up or down)\n  // Positive values mean we added to `coin` to cushion drop,\n  // negative values mean we subbed from `coin` to cushion jump\n  int coinAdjustment;\n\n  // When did this account attach?\n  uint initTime;\n\n  // When did we last adjust the cushioning?\n  uint lastDrawDownTime;\n\n  // Averages used to calculate drawdown\n  int avgFiatPrincipal;\n  int avgCoinPrincipal;\n  uint lastAvgAdjustTime;\n\n  // Used to calculate the down cushion\n  int reserved;\n  int maxCovered;\n  int maxCoverAdjust;\n}\n\n\ncontract ShockAbsorber is BasePlugin, OracleClient, OwnableUpgradeable, PermissionUser {\n\n  // By default, we protect up to $5000\n  int constant maxFiatProtected = 5000_00;\n  // Essentially how many significant figures when doing floating point math.\n  int constant FLOAT_FACTOR = 100_000_000_000;\n  int constant FLOAT_FACTOR_SQ = FLOAT_FACTOR * FLOAT_FACTOR;\n  // milliseconds in a gregorian year.  Should be accurate for the next 1000 years.\n  int constant YEAR_IN_MS = 31556952_000;\n\n  // The percentage drop absorbed\n  int maxCushionDown;\n\n  // What percentage yearly gains go towards\n  // building the cushion?\n  int maxCushionUp;\n\n  int maxCushionUpPercent;\n\n  mapping(address => UserCushion) cushions;\n\n  uint numClients;\n\n  // Link back to core contract.\n  IPluggable internal theCoin;\n\n  function initialize(address baseContract, address oracle) public initializer {\n    __Ownable_init();\n\n    setFeed(oracle);\n    theCoin = IPluggable(baseContract);\n\n    // The amount of down to absorb is 50%\n    maxCushionDown = (50 * FLOAT_FACTOR) / 100;\n    // The cushionUp is first 1.5% of profit.\n    maxCushionUp = (15 * FLOAT_FACTOR) / 1000;\n    maxCushionUpPercent = FLOAT_FACTOR - (FLOAT_FACTOR * FLOAT_FACTOR / (FLOAT_FACTOR + maxCushionUp));\n  }\n\n  function getCushion(address user) public view returns(UserCushion memory) {\n    return cushions[user];\n  }\n\n  // ------------------------------------------------------------------------\n  // IPlugin Implementation\n  // ------------------------------------------------------------------------\n  // We modify transfers\n  function getPermissions() override external pure returns(uint) {\n    return PERMISSION_BALANCE & PERMISSION_DEPOSIT & PERMISSION_WITHDRAWAL & PERMISSION_AUTO_ACCESS;\n  }\n\n  function userAttached(address user, address) override external onlyBaseContract {\n    require(cushions[user].fiatPrincipal == 0, \"User is already attached\");\n    require(numClients < 25, \"Client limit reached\");\n\n    uint timeMs = msNow();\n    int coinBalance = theCoin.pl_balanceOf(user);\n    int fiatBalance = toFiat(coinBalance, timeMs);\n    int maxCovered = (FLOAT_FACTOR * int(coinBalance)) / (FLOAT_FACTOR - maxCushionDown);\n    cushions[user].fiatPrincipal = fiatBalance;\n    cushions[user].maxCovered = maxCovered;\n    cushions[user].lastAvgAdjustTime = timeMs;\n    cushions[user].lastDrawDownTime = timeMs;\n    cushions[user].initTime = timeMs;\n\n    emit ValueChanged(user, timeMs, \"cushions[user].fiatPrincipal\", fiatBalance);\n    emit ValueChanged(user, timeMs, \"cushions[user].maxCovered\", maxCovered);\n    emit ValueChanged(user, timeMs, \"cushions[user].lastAvgAdjustTime\", int(timeMs));\n    emit ValueChanged(user, timeMs, \"cushions[user].initTime\", int(timeMs));\n\n    numClients = numClients + 1;\n  }\n\n  function userDetached(address exClient, address /*initiator*/) override external onlyBaseContract {\n    // NOTE: THIS IS NOT TESTED (hopefully don't use it for a few years...)\n    // IT PROBABLY WONT WORK AS EXPECTED DUE TO FRACTIONAL YEARS NOT TESTED\n    _drawDownCushion(exClient, msNow());\n    delete cushions[exClient];\n    numClients = numClients - 1;\n  }\n\n  // We automatically modify the balance to adjust for market fluctuations.\n  function balanceOf(address user, int currentBalance) external view override returns(int)\n  {\n    // console.log(\"currentBalance: \", uint(currentBalance));\n    UserCushion storage userCushion = cushions[user];\n\n    uint timeMs = msNow();\n    // int coinPrincipal = toCoin(userCushion.fiatPrincipal, timeMs);\n    int currentFiat = toFiat(currentBalance, timeMs);\n    int fiatPrincipal = userCushion.fiatPrincipal;\n    if (currentFiat < fiatPrincipal) {\n      int cushion = calcCushionDown(userCushion, currentBalance, timeMs);\n      return currentBalance + cushion;\n    }\n    else if (currentFiat > fiatPrincipal) {\n      int reserve = calcCushionUp(userCushion, currentBalance, timeMs);\n      return currentBalance - reserve;\n    }\n    else {\n      return currentBalance;\n    }\n  }\n\n  // Public-access for testing\n  function calcCushionUp(address user, int coinBalance, uint timeMs) public view returns(int) {\n    UserCushion storage userCushion = cushions[user];\n    return calcCushionUp(userCushion, coinBalance, timeMs);\n  }\n\n  function calcCushionUp(UserCushion storage user, int coinBalance, uint timeMs) internal view returns(int) {\n    if (user.fiatPrincipal == 0) {\n      return 0;\n    }\n\n    // The reserve amount applies fresh each year\n    int msPassed = int(timeMs - user.initTime);\n    // console.log(\"msPassed: \", uint(msPassed));\n    int year = int(msPassed / YEAR_IN_MS);\n    // console.log(\"year: \", uint(year));\n\n    int coinPrincipal = toCoin(user.fiatPrincipal, timeMs);\n    int coinOriginal = coinBalance + user.reserved;\n    // console.log(\"coinOriginal: \", uint(coinOriginal));\n    // console.log(\"coinPrincipal: \", uint(coinPrincipal));\n\n    int percentCovered = (FLOAT_FACTOR * maxFiatProtected) / user.fiatPrincipal;\n    if (percentCovered > FLOAT_FACTOR) {\n      percentCovered = FLOAT_FACTOR;\n    }\n    // console.log(\"percentCovered: \", uint(percentCovered));\n\n    int maxPercentCushion = getMaxPercentCushion((1 + year) * YEAR_IN_MS);\n    // console.log(\"maxPercentCushion: \", uint(maxPercentCushion));\n    int coinMaxCushion = (maxPercentCushion * coinOriginal) / FLOAT_FACTOR;\n    // console.log(\"coinMaxCushion: \", uint(coinMaxCushion));\n\n    int coinCushion = coinOriginal - coinPrincipal;\n    // console.log(\"coinCushion: \", uint(coinCushion));\n    int coinCovered = coinCushion;\n    if (coinCushion > coinMaxCushion) {\n      coinCovered = coinMaxCushion;\n    }\n    int r = ((coinCovered * percentCovered) / FLOAT_FACTOR) - user.reserved;\n    // console.log(\"r: \", uint(r));\n    return r;\n  }\n\n  // Public-access for testing\n  function calcCushionDown(address user, int coinBalance, uint timeMs) public view returns(int) {\n    UserCushion storage userCushion = cushions[user];\n    return calcCushionDown(userCushion, coinBalance, timeMs);\n  }\n\n  function calcCushionDown(UserCushion storage user, int coinBalance, uint timeMs) internal view returns(int) {\n    if (user.fiatPrincipal == 0) {\n      return 0;\n    }\n\n    int coinPrincipal = toCoin(user.fiatPrincipal, timeMs);\n    int coinOriginal = coinBalance + user.reserved;\n    // console.log(\"coinOriginal: \", uint(coinOriginal));\n    // console.log(\"user.reserved: \", uint(user.reserved));\n\n    int percentCovered = (maxFiatProtected * FLOAT_FACTOR) / user.fiatPrincipal;\n    if (percentCovered > FLOAT_FACTOR) {\n      percentCovered = FLOAT_FACTOR;\n    }\n    // console.log(\"percentCovered: \", uint(percentCovered));\n\n    int coinCovered = user.maxCovered;\n    if (coinCovered > coinPrincipal) {\n      coinCovered = coinPrincipal;\n    }\n    // console.log(\"coinCovered: \", uint(coinCovered));\n\n    int target = percentCovered * coinCovered;\n    // console.log(\"target: \", uint(target / FLOAT_FACTOR));\n    int original = (percentCovered * coinOriginal) - (user.reserved * FLOAT_FACTOR);\n    // console.log(\"original: \", uint(original / FLOAT_FACTOR));\n\n    return (target - original) / FLOAT_FACTOR;\n  }\n\n  function getMaxPercentCushion(int timeMs) public view returns(int) {\n    return FLOAT_FACTOR - (FLOAT_FACTOR_SQ / (FLOAT_FACTOR + maxCushionUp * (timeMs / YEAR_IN_MS)));\n  }\n  function getAnnualizedValue(uint lastAvgAdjustTime, uint timeMs, int value) public pure returns(int) {\n    if (timeMs <= lastAvgAdjustTime) return 0;\n    int timeChange = FLOAT_FACTOR * int(timeMs - lastAvgAdjustTime);\n    int percentOfYear = timeChange / YEAR_IN_MS;\n    int annualizedAvg = value * percentOfYear;\n    return annualizedAvg / FLOAT_FACTOR;\n  }\n  function getAvgFiatPrincipal(address user, uint timeMs) public view returns(int) {\n    UserCushion storage userCushion = cushions[user];\n    return userCushion.avgFiatPrincipal + this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, userCushion.fiatPrincipal);\n  }\n  function getAvgCoinBalance(address user, uint timeMs) public view returns(int) {\n    UserCushion storage userCushion = cushions[user];\n    int coinBalance = theCoin.pl_balanceOf(user);\n    return userCushion.avgCoinPrincipal + this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, coinBalance);\n  }\n\n  // ------------------------------------------------------------------------\n  // transactions change the principal\n  // ------------------------------------------------------------------------\n\n  function preDeposit(address user, uint coinBalance, uint coinDeposit, uint timeMs) public virtual override  {\n    int fiatDeposit = toFiat(int(coinDeposit), timeMs);\n    // console.log(\"preDeposit: \", uint(fiatDeposit));\n    UserCushion storage userCushion = cushions[user];\n\n    userCushion.avgFiatPrincipal += this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, userCushion.fiatPrincipal);\n    userCushion.avgCoinPrincipal += this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, int(coinBalance));\n    // console.log(\"userCushion.avgCoinPrincipal: \", uint(userCushion.avgCoinPrincipal));\n\n    int depositRatio = FLOAT_FACTOR;\n    if (userCushion.fiatPrincipal != 0) {\n      // console.log(\"denominator: \", uint(userCushion.maxCovered * maxCushionDown));\n      int ratioOfExisting = (FLOAT_FACTOR_SQ * int(coinDeposit)) / (userCushion.maxCovered * maxCushionDown);\n      // console.log(\"ratioOfExisting: \", uint(ratioOfExisting));\n      depositRatio = (FLOAT_FACTOR_SQ * fiatDeposit / userCushion.fiatPrincipal) / ratioOfExisting;\n    }\n    // console.log(\"depositRatio: \", uint(depositRatio));\n\n    userCushion.fiatPrincipal += fiatDeposit;\n\n    int maxCoverAdjust = (FLOAT_FACTOR - depositRatio) * int(coinDeposit) / (FLOAT_FACTOR - maxCushionDown);\n    int maxCoverForCoin = (FLOAT_FACTOR * int(coinDeposit)) / (FLOAT_FACTOR - maxCushionDown);\n\n    // In profit\n    if (maxCoverAdjust < 0 && maxCoverForCoin > userCushion.maxCoverAdjust) {\n      // If adjusting for a withdrawal on loss\n      if (userCushion.maxCoverAdjust > 0) {\n        userCushion.maxCovered += maxCoverForCoin - maxCoverAdjust;\n        userCushion.maxCoverAdjust += maxCoverAdjust;\n      }\n      // Else eliminate adjustments for a withdrawal on profit\n      else {\n        userCushion.maxCovered += maxCoverForCoin - userCushion.maxCoverAdjust;\n        userCushion.maxCoverAdjust = 0;\n      }\n    }\n    else {\n      if (maxCoverForCoin > userCushion.maxCoverAdjust) {\n        int adjust = userCushion.maxCoverAdjust;\n        if (adjust > maxCoverAdjust) {\n          adjust = maxCoverAdjust;\n        }\n        maxCoverForCoin -= adjust;\n        userCushion.maxCoverAdjust -= adjust;\n      } else {\n        userCushion.maxCoverAdjust -= maxCoverAdjust;\n      }\n      userCushion.maxCovered += maxCoverForCoin;\n    }\n    userCushion.lastAvgAdjustTime = timeMs;\n\n    emit ValueChanged(user, timeMs, \"cushions[user].fiatPrincipal\", userCushion.fiatPrincipal);\n    emit ValueChanged(user, timeMs, \"cushions[user].maxCovered\", userCushion.maxCovered);\n  }\n\n  function preWithdraw(address user, uint coinBalance, uint coinWithdraw, uint timeMs) public virtual override returns(uint) {\n    UserCushion storage userCushion = cushions[user];\n    int fiatWithdraw = toFiat(int(coinWithdraw), timeMs);\n    // console.log(\"preWithdraw: \", uint(fiatWithdraw));\n    int ratioOfExisting = (FLOAT_FACTOR_SQ * int(coinWithdraw)) / (userCushion.maxCovered * maxCushionDown);\n    // console.log(\"ratioOfExisting: \", uint(ratioOfExisting));\n    int withdrawRatio = (FLOAT_FACTOR_SQ * fiatWithdraw / userCushion.fiatPrincipal) / ratioOfExisting;\n    // console.log(\"withdrawRatio: \", uint(withdrawRatio));\n\n    if (coinBalance < coinWithdraw) {\n      // In Loss, run CushionDown\n      uint additionalRequired = coinWithdraw - coinBalance;\n      // console.log(\"additionalRequired: \", additionalRequired);\n      int maxCushion = calcCushionDown(userCushion, int(coinBalance), timeMs);\n      // console.log(\"maxCushion: \", uint(maxCushion));\n      require(additionalRequired <= uint(maxCushion), \"Insufficient funds\");\n      // transfer additionalRequired to this users account\n      theCoin.pl_transferTo(user, additionalRequired, timeMs);\n    }\n\n    userCushion.avgFiatPrincipal += this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, userCushion.fiatPrincipal);\n    userCushion.avgCoinPrincipal += this.getAnnualizedValue(userCushion.lastAvgAdjustTime, timeMs, int(coinBalance));\n    userCushion.fiatPrincipal -= fiatWithdraw;\n    userCushion.lastAvgAdjustTime = timeMs;\n\n    userCushion.maxCoverAdjust += (FLOAT_FACTOR - withdrawRatio) * int(coinWithdraw) / (FLOAT_FACTOR - maxCushionDown);\n    userCushion.maxCovered -= withdrawRatio * int(coinWithdraw) / (FLOAT_FACTOR - maxCushionDown);\n\n    emit ValueChanged(user, timeMs, \"cushions[user].fiatPrincipal\", userCushion.fiatPrincipal);\n    emit ValueChanged(user, timeMs, \"cushions[user].maxCovered\", userCushion.maxCovered);\n\n    return coinWithdraw;\n  }\n\n  // ------------------------------------------------------------------------\n  // Owners functionality\n  // ------------------------------------------------------------------------\n  function drawDownCushion(address user, uint timeMs) public onlyOwner() {\n    _drawDownCushion(user, timeMs);\n  }\n\n  function _drawDownCushion(address user, uint timeMs) internal {\n    require(timeMs < msNow(), \"Time must be in the past\");\n    // console.log(\"*** drawDownCushion timeMs: \", uint(timeMs));\n    int avgCoinPrincipal = this.getAvgCoinBalance(user,timeMs);\n    // console.log(\"avgCoinPrincipal: \", uint(avgCoinPrincipal));\n    int avgFiatPrincipal = this.getAvgFiatPrincipal(user, timeMs);\n    // console.log(\"avgFiatPrincipal: \", uint(avgFiatPrincipal));\n\n    // Prevent divide-by-zero\n    if (avgCoinPrincipal == 0 || avgFiatPrincipal == 0) {\n      return;\n    }\n    UserCushion storage userCushion = cushions[user];\n    // How can we limit this to the maxiumum of the maxCushionUpPercent?\n    int covered = (FLOAT_FACTOR * maxFiatProtected) / avgFiatPrincipal;\n    if (covered > FLOAT_FACTOR) {\n      covered = FLOAT_FACTOR;\n    }\n    // console.log(\"covered: \", uint(covered));\n\n    // We always reserve the maximum percent, ignoring current rates\n    // CushionDown ensures that this does not take balance below principal\n    // console.log(\"userCushion.lastDrawDownTime: \", uint(userCushion.lastDrawDownTime));\n    int timeSinceLastDrawDown = int(timeMs - userCushion.lastDrawDownTime);\n    // console.log(\"timeSinceLastDrawDown: \", uint(timeSinceLastDrawDown));\n    int percentCushion = this.getMaxPercentCushion(timeSinceLastDrawDown);\n    // console.log(\"percentCushion: \", uint(percentCushion));\n    // How many coins we gonna keep now?\n    int toReserve = (covered * percentCushion * avgCoinPrincipal) / (FLOAT_FACTOR * FLOAT_FACTOR);\n    // console.log(\"toReserve: \", uint(toReserve));\n\n    // If nothing to do, do nothing\n    if (toReserve == 0) {\n      return;\n    }\n\n    // Transfer the reserve to this contract\n    theCoin.pl_transferFrom(user, address(this), uint(toReserve), timeMs);\n    userCushion.reserved += toReserve;\n    userCushion.lastDrawDownTime = timeMs;\n    userCushion.lastAvgAdjustTime = timeMs;\n\n    emit ValueChanged(user, timeMs, \"cushions[user].reserved\", userCushion.reserved);\n    emit ValueChanged(user, timeMs, \"cushions[user].lastDrawDownTime\", int(userCushion.lastDrawDownTime));\n  }\n\n  function withdraw(uint amount) internal onlyOwner() {\n    theCoin.pl_transferFrom(address(this), owner(), amount, msNow());\n  }\n\n  // ------------------------------------------------------------------------\n  // Modifiers\n  // ------------------------------------------------------------------------\n  modifier onlyBaseContract()\n  {\n    require(msg.sender == address(theCoin), \"Only callable from the base contract\");\n    _;\n  }\n}\n\n"}