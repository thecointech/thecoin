'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var prettier = require('prettier');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const warningMessage = `
/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */
`;
const TYPES = {
  string: 'string',
  integer: 'number',
  number: 'number'
};

function capitalize(str) {
  return `${str[0].toUpperCase()}${str.slice(1)}`;
}

function camelCase(name) {
  return name.replace(/(-|_|\.|\s)+\w/g, letter => letter.toUpperCase().replace(/[^0-9a-z]/gi, ''));
}

function sanitize(name) {
  return name.includes('-') ? `'${name}'` : name;
}

function spacesToUnderscores(name) {
  return name.replace(/\s/g, '_');
}

function parse(spec, options = {}) {
  const shouldUseWrapper = options.wrapper !== false;
  const wrapper = typeof options.wrapper === 'string' && options.wrapper ? options.wrapper : 'declare namespace OpenAPI2';
  const shouldCamelCase = options.camelcase || false;
  const shouldInsertWarning = options.injectWarning || false;
  const queue = [];
  const output = [];

  if (shouldInsertWarning) {
    output.push(warningMessage);
  }

  if (wrapper && shouldUseWrapper) {
    output.push(`${wrapper} {`);
  }

  const {
    definitions
  } = spec;

  function getRef(lookup) {
    const ID = lookup.replace('#/definitions/', '');
    const ref = definitions[ID];
    return [ID, ref];
  }

  function getType(definition, nestedName) {
    const {
      $ref,
      items,
      type
    } = definition,
          value = _objectWithoutProperties(definition, ["$ref", "items", "type"]);

    const nextInterface = camelCase(nestedName);
    const DEFAULT_TYPE = 'any';

    if ($ref) {
      const [refName, refProperties] = getRef($ref);
      const convertedRefName = spacesToUnderscores(refName);

      if (refProperties.items && refProperties.items.$ref) {
        return getType(refProperties, refName);
      }

      if (refProperties.type && TYPES[refProperties.type]) {
        return TYPES[refProperties.type];
      }

      return convertedRefName || DEFAULT_TYPE;
    }

    if (items && items.$ref) {
      const [refName] = getRef(items.$ref);
      return `${getType(items, refName)}[]`;
    }

    if (items && items.type) {
      if (items.type === 'array') {
        return `${getType(items, nestedName)}[]`;
      }

      if (TYPES[items.type]) {
        return `${TYPES[items.type]}[]`;
      }

      queue.push([nextInterface, items]);
      return `${nextInterface}[]`;
    }

    if (Array.isArray(value.oneOf)) {
      return value.oneOf.map(def => getType(def, '')).join(' | ');
    }

    if (value.properties) {
      queue.push([nextInterface, _objectSpread2({
        $ref,
        items,
        type
      }, value)]);
      return nextInterface;
    }

    if (type) {
      return TYPES[type] || type || DEFAULT_TYPE;
    }

    return DEFAULT_TYPE;
  }

  function buildNextInterface() {
    const nextObject = queue.pop();
    if (!nextObject) return;
    const [ID, {
      allOf,
      properties,
      required,
      additionalProperties,
      type
    }] = nextObject;
    let allProperties = properties || {};
    const includes = [];

    if (Array.isArray(allOf)) {
      allOf.forEach(item => {
        if (item.$ref) {
          const [refName] = getRef(item.$ref);
          includes.push(refName);
        } else if (item.properties) {
          allProperties = _objectSpread2({}, allProperties, {}, item.properties);
        }
      });
    }

    if (!Object.keys(allProperties).length && additionalProperties !== true && type && TYPES[type]) {
      return;
    }

    const isExtending = includes.length ? ` extends ${includes.join(', ')}` : '';
    output.push(`export interface ${shouldCamelCase ? camelCase(ID) : spacesToUnderscores(ID)}${isExtending} {`);
    Object.entries(allProperties).forEach(([key, value]) => {
      const optional = !Array.isArray(required) || required.indexOf(key) === -1;
      const formattedKey = shouldCamelCase ? camelCase(key) : key;
      const name = `${sanitize(formattedKey)}${optional ? '?' : ''}`;
      const newID = `${ID}${capitalize(formattedKey)}`;
      const interfaceType = getType(value, newID);

      if (typeof value.description === 'string') {
        output.push(`/**\n* ${value.description.replace(/\n$/, '').replace(/\n/g, '\n* ')}\n*/`);
      }

      if (Array.isArray(value.enum)) {
        output.push(`${name}: ${value.enum.map(option => JSON.stringify(option)).join(' | ')};`);
        return;
      }

      output.push(`${name}: ${interfaceType};`);
    });

    if (additionalProperties) {
      if (additionalProperties === true) {
        output.push('[name: string]: any');
      }

      if (additionalProperties.type) {
        const interfaceType = getType(additionalProperties, '');
        output.push(`[name: string]: ${interfaceType}`);
      }
    }

    output.push('}');
  }

  Object.entries(definitions).forEach(entry => {
    if (typeof entry[1] === 'object') {
      queue.push(entry);
    }
  });
  queue.sort((a, b) => a[0].localeCompare(b[0]));

  while (queue.length > 0) {
    buildNextInterface();
  }

  if (wrapper && shouldUseWrapper) {
    output.push('}');
  }

  return prettier.format(output.join('\n'), {
    parser: 'typescript',
    singleQuote: true
  });
}

function index (spec, options) {
  const swagger = options && options.swagger || 2;

  if (swagger !== 2) {
    throw new Error(`Swagger version ${swagger} is not supported`);
  }

  return parse(spec, options);
}

exports.default = index;
//# sourceMappingURL=index.js.map
