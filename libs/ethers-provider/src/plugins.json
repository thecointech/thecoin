{
  "UberConverter": {
    "address": "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
    "code": "/// @title Convert Currency & Time on-chain\n/// @author Stephen Taylor\n/// @notice This plugin unlocks TheCoin from being tied to the stock\n/// market.  It allows converting currencies online and implements\n/// a delayable non-revokable allowance to permit Brokers to complete\n/// payments outside of trading hours, letting the trades settle at the\n/// time specified.\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport '@thecointech/contract-oracle/contracts/OracleClient.sol';\nimport '@thecointech/contract-plugins/contracts/BasePlugin.sol';\nimport '@thecointech/contract-plugins/contracts/permissions.sol';\nimport '@thecointech/contract-plugins/contracts/IPluggable.sol';\n\nimport \"hardhat/console.sol\";\n\nstruct PendingTransactions {\n  // The currency code of the value (eg 124 for $CAD)\n  // uint8 currency;\n  // For now, just assume CAD\n  // We could (?) provide a new Converter per-currency?\n  // The total value owed to all users (in currency)\n  uint total;\n  // to => timestamp => value\n  mapping(address => mapping(uint => uint)) transfers;\n}\n\n\ncontract UberConverter is BasePlugin, OracleClient, Ownable, PermissionUser {\n\n  // We list \"to\" first, as that is the value most likely to be repeated\n  // From => { To => Timestamp => Value }\n  mapping(address => PendingTransactions) pending;\n\n  // Link back to core contract.\n  IPluggable internal theCoin;\n\n  // The currency code this client supports.\n  uint16 constant CurrencyCode = 124;\n\n  constructor(address baseContract, address oracle)\n  {\n    setFeed(oracle);\n    theCoin = IPluggable(baseContract);\n  }\n\n  // We modify transfers\n  function getPermissions() override external pure returns(uint) {\n    return PERMISSION_AUTO_ACCESS & PERMISSION_WITHDRAWAL;\n  }\n\n  // If this is a new user, we initialize the guard to their fiat amount.\n  function userAttached(address newUser, address initiator) override external onlyBaseContract {\n\n  }\n\n  // When a user removes this plugin, we clear any balance owing.\n  function userDetached(address exClient, address initiator) override external onlyBaseContract {\n    require(owner() == initiator, \"only owner may detach this plugin\");\n    // Total == 0 means no transfers remaining\n    require(pending[exClient].total == 0, \"Cannot remove plugin while a transaction is pending\");\n    delete pending[exClient];\n  }\n\n  // We automatically modify the balance to adjust for market fluctuations.\n  function balanceOf(address user, int currentBalance) external view override returns(int)\n  {\n    PendingTransactions storage userPending = pending[user];\n    if (userPending.total != 0) {\n      // How much does our owed amount turn into?\n      uint owed = toCoin(userPending.total, block.timestamp);\n      return currentBalance - int(owed);\n    }\n    return currentBalance;\n  }\n\n  //\n  // What do we want to do about this particular transaction?\n  function modifyTransfer(address from, address to, uint amount, uint16 currency, uint timestamp)\n    external override onlyBaseContract\n    returns (uint finalAmount, uint16 finalCurrency)\n  {\n    (finalAmount, finalCurrency) = (amount, currency);\n    // We only care about CAD  transactions\n    if (currency == CurrencyCode) {\n\n      // If this is scheduled to happen in the future?\n      console.log(\"Converting Transfer at\", timestamp, \" in block \", block.timestamp);\n\n      if (timestamp > block.timestamp) {\n        pending[from].transfers[to][timestamp] = pending[from].transfers[to][timestamp] + amount;\n        pending[from].total = pending[from].total + amount;\n        finalAmount = 0;\n        emit ValueChanged(from, timestamp, \"pending[user].total\", int(pending[from].total));\n      }\n      // Happening now, so convert to Coin\n      else {\n        finalAmount = toCoin(amount, timestamp);\n        finalCurrency = 0;\n      }\n    }\n    return (finalAmount, finalCurrency);\n  }\n\n  // This function can be safely made public as it can only\n  // process transactions that have already been registered\n  function processPending(address from, address to, uint timestamp) public\n  {\n    require(timestamp <= block.timestamp, \"Cannot process future transactions\");\n\n    PendingTransactions storage user = pending[from];\n    uint fiat = user.transfers[to][timestamp];\n    if (fiat > 0) {\n      uint coin = uint(toCoin(fiat, timestamp));\n      theCoin.pl_transferFrom(from, to, coin);\n      delete user.transfers[to][timestamp];\n      user.total = user.total - fiat;\n      emit ValueChanged(from, timestamp, \"pending[user].total\", int(user.total));\n    }\n  }\n  // ------------------------------------------------------------------------\n  // Pending transactions prevent withdrawals\n  // ------------------------------------------------------------------------\n  function preWithdraw(address user, uint balance, uint coin, uint timestamp) public virtual override returns(uint) {\n    uint userPending = pending[user].total;\n    if (userPending != 0) {\n      // How much does our owed amount turn into?\n      uint owed = toCoin(userPending, timestamp);\n      require((owed + coin) <= balance, \"Cannot withdraw, exceeds balance\");\n      return balance - owed;\n    }\n    return balance;\n  }\n\n  // ------------------------------------------------------------------------\n  // Modifiers\n  // ------------------------------------------------------------------------\n  modifier onlyBaseContract()\n  {\n    require(msg.sender == address(theCoin), \"Action requires Plugin Manager role\");\n    _;\n  }\n}\n\n"
  },
  "RoundNumber": {
    "address": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
    "code": "// ----------------------------------------------------------------------------\n/// @title RoundNumber demo plugin\n/// @author Stephen Taylor\n/// @notice A simple plugin intended to test plugin funtionality.\n/// Rounds the users balance down to the nearest $100 in fiat\n/// @dev This is a sample plugin and not intended for production\n// ----------------------------------------------------------------------------\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport '@thecointech/contract-plugins/contracts/BasePlugin.sol';\nimport '@thecointech/contract-plugins/contracts/permissions.sol';\nimport '@thecointech/contract-oracle/contracts/OracleClient.sol';\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract RoundNumber is BasePlugin, OracleClient, Ownable, PermissionUser {\n\n  constructor(address oracle) {\n    setFeed(oracle);\n  }\n\n  // Round to the nearest $100 (10K cents)\n  int DEFAULT_ROUND_POINT = 10000;\n\n  // Users can specify their own rounding point\n  mapping(address => int) UserRounding;\n\n  // We modify the users balance to reflect what they can actually spend.\n  // When a withdrawal occurs we may boost the\n  function getPermissions() override external pure returns(uint) {\n    return PERMISSION_BALANCE;\n  }\n\n  function setRoundPoint(int newRoundPoint, uint timestamp) public {\n    UserRounding[msg.sender] = newRoundPoint;\n    emit ValueChanged(msg.sender, timestamp, \"UserRounding[user]\", newRoundPoint);\n  }\n\n  function balanceOf(address user, int currentBalance) external view override returns(int){\n    // Fiat is in cents\n    int fiat = toFiat(currentBalance, block.timestamp);\n    int roundPoint = UserRounding[user];\n    if(roundPoint == 0) {\n      roundPoint = DEFAULT_ROUND_POINT;\n    }\n    int rounded = (fiat / roundPoint) * roundPoint;\n    return toCoin(rounded, block.timestamp);\n  }\n}\n\n"
  }
}
