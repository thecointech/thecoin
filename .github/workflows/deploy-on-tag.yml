name: Deploy on Tag

on:
  push:
    tags:
      - 'v*.*.*-test.*'
      - 'v*.*.*-beta.*'
      - 'v*.*.*'

# Prevent multiple deployments of the same tag from running simultaneously
# but allow them to queue rather than canceling in-progress deployments
concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false  # Don't cancel deployments in progress

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.parse.outputs.env }}
      is_prerelease: ${{ steps.parse.outputs.prerelease }}
    steps:
      - name: Parse tag to determine environment
        id: parse
        env:
          TAG: ${{ github.ref_name }}
        run: |
          echo "Deploying tag: $TAG"

          if [[ "$TAG" =~ -test\. ]]; then
            echo "env=prodtest" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Deploying to: prodtest"
          elif [[ "$TAG" =~ -beta\. ]]; then
            echo "env=prodbeta" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Deploying to: prodbeta"
          else
            echo "env=prod" >> "$GITHUB_OUTPUT"
            echo "prerelease=false" >> "$GITHUB_OUTPUT"
            echo "Deploying to: prod"
          fi

  # Graduate packages for stable tags (v*.*.* without -test.* or -beta.*)
  graduate-packages:
    if: needs.determine-environment.outputs.environment == 'prod'
    needs: determine-environment
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - run: corepack enable

      - uses: actions/setup-node@v4
        with:
          node-version: '22.19'
          cache: 'yarn'

      - name: Configure Git
        run: |
          git config user.name 'GitHub Actions Bot'
          git config user.email '41898282+github-actions[bot]@users.noreply.github.com'

      - name: Install dependencies
        run: yarn install --immutable --mode=skip-build

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Graduate Packages
        run: |
          # Get current stable tag
          STABLE_TAG=${{ github.ref_name }}
          BASE_VERSION=$(echo "$STABLE_TAG" | sed 's/^v//')

          echo "üéì Graduating packages to stable version $BASE_VERSION"

          # Find the corresponding test tag
          TEST_TAG=$(git tag --sort=-version:refname | grep "^v$BASE_VERSION-test\." | head -1)

          if [ -z "$TEST_TAG" ]; then
            echo "‚ö†Ô∏è  No test tag found, assuming packages are already stable"
            echo "Skipping graduation, will use current tag commit"
          else
            echo "üìå Found test tag: $TEST_TAG"
            echo "Graduating packages from test to stable"

            # Get the test tag's commit to use as reference
            TEST_COMMIT=$(git rev-list -n 1 "$TEST_TAG")
            echo "Test tag $TEST_TAG points to commit: $TEST_COMMIT"

            # Graduate packages (removes prerelease suffix) from current state
            yarn lerna version --conventional-graduate --yes

            # Verify yarn.lock is consistent with updated package.json files
            yarn install --immutable

            # Move the stable tag to point to the new graduated commit
            git tag -f "$STABLE_TAG"

            # Push the graduated packages and moved tag (using GITHUB_TOKEN to avoid recursive workflow)
            git push origin --tags
          fi

  update-metadata:
    needs: [determine-environment, graduate-packages]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - run: corepack enable

      - uses: actions/setup-node@v4
        with:
          node-version: '22.19'

      - name: Update deployment metadata for this environment
        run: |
          # Update timestamp to actual deployment time
          # Strip prerelease suffix: 0.5.3-test.0 ‚Üí 0.5.3
          node --experimental-strip-types ./tools/updateEnvVersion.ts
          echo "Updated to version $(grep TC_APP_VERSION environments/common.public.env | cut -d'"' -f2) at $(grep TC_DEPLOYED_AT environments/common.public.env | cut -d'"' -f2)"

      - name: Upload updated metadata
        uses: actions/upload-artifact@v4
        with:
          name: deployment-metadata
          path: environments/common.public.env

  checkout-graduated:
    needs: [determine-environment, graduate-packages]
    runs-on: ubuntu-latest
    outputs:
      commit: ${{ steps.get-commit.outputs.commit }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Graduated Commit
        id: get-commit
        run: |
          # For stable tags, get the commit from the graduated packages
          STABLE_TAG=${{ github.ref_name }}
          BASE_VERSION=$(echo "$STABLE_TAG" | sed 's/^v//')

          if [ "${{ needs.determine-environment.outputs.environment }}" == "prod" ]; then
            # Find the test tag that was graduated
            TEST_TAG=$(git tag --sort=-version:refname | grep "^v$BASE_VERSION-test\." | head -1)

            if [ -n "$TEST_TAG" ]; then
              # Get the commit that Lerna created during graduation
              # This will be the commit after the test tag with stable package versions
              COMMIT=$(git rev-list -n 1 "$STABLE_TAG")
              echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
              echo "üìå Using graduated commit: $COMMIT"
            else
              # Fallback to current tag commit
              COMMIT=$(git rev-list -n 1 "$STABLE_TAG")
              echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è  Using tag commit: $COMMIT"
            fi
          else
            # For test/beta, use current tag commit
            COMMIT=$(git rev-list -n 1 "$STABLE_TAG")
            echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
            echo "üìå Using tag commit: $COMMIT"
          fi

  build:
    needs: [determine-environment, update-metadata, checkout-graduated]
    uses: ./.github/workflows/action-build.yml
    with:
      DOWNLOAD_METADATA: true
      # Pass the graduated commit to the build workflow
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  test:
    needs: build
    uses: ./.github/workflows/action-test.yml
    with:
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  # Publish packages only for test tags (initial publish)
  publish-packages-test:
    if: contains(github.ref_name, '-test.')
    needs: test
    permissions:
      packages: write
    uses: ./.github/workflows/action-publish-packages.yml
    with:
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  # Graduate packages for production tags
  publish-packages-prod:
    if: needs.determine-environment.outputs.is_prerelease == 'false'
    needs: [test, determine-environment]
    permissions:
      packages: write
    uses: ./.github/workflows/action-publish-packages.yml
    with:
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  # Wait for package publishing to complete before deploying
  wait-for-packages:
    needs: [publish-packages-test, publish-packages-prod, determine-environment]
    # Run unless workflow was cancelled or a package publish actually failed
    # This is needed because beta tags do not publish packages (both jobs skip)
    # Beta reuses test packages, so we still need to proceed with deployment
    if: ${{ always() && !cancelled() && !failure() }}
    runs-on: ubuntu-latest
    steps:
      - name: Check package publish status
        run: |
          TEST_RESULT="${{ needs.publish-packages-test.result }}"
          PROD_RESULT="${{ needs.publish-packages-prod.result }}"
          IS_PRERELEASE="${{ needs.determine-environment.outputs.is_prerelease }}"
          IS_TEST_TAG="${{ contains(github.ref_name, '-test.') }}"

          echo "Package publish results:"
          echo "  Test job: $TEST_RESULT"
          echo "  Prod job: $PROD_RESULT"
          echo ""

          # Determine which job was required for this tag
          if [ "$IS_PRERELEASE" = "true" ]; then
            if [ "$IS_TEST_TAG" = "true" ]; then
              echo "Test tag - checking test package publish"
              if [ "$TEST_RESULT" != "success" ] && [ "$TEST_RESULT" != "skipped" ]; then
                echo "‚ùå Test package publish failed: $TEST_RESULT"
                exit 1
              fi
              echo "‚úÖ Test packages published successfully"
            else
              echo "Beta tag - reusing test packages (no publish required)"
            fi
          else
            echo "Prod tag - checking prod package graduation"
            if [ "$PROD_RESULT" != "success" ] && [ "$PROD_RESULT" != "skipped" ]; then
              echo "‚ùå Prod package graduation failed: $PROD_RESULT"
              exit 1
            fi
            echo "‚úÖ Packages graduated successfully"
          fi

  publish-docker:
    needs: [wait-for-packages, determine-environment]
    # Explicit condition needed because wait-for-packages uses if: always()
    if: ${{ always() && !cancelled() && !failure() }}
    uses: ./.github/workflows/action-publish-docker.yml
    secrets: inherit
    with:
      CONFIG_NAME: ${{ needs.determine-environment.outputs.environment }}
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}
      IS_PROMOTION: ${{ !contains(github.ref_name, '-test.') }}

  publish-services:
    needs: [wait-for-packages, determine-environment]
    # Explicit condition needed because wait-for-packages uses if: always()
    if: ${{ always() && !cancelled() && !failure() }}
    uses: ./.github/workflows/action-publish-services.yml
    secrets: inherit
    with:
      CONFIG_NAME: ${{ needs.determine-environment.outputs.environment }}
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  publish-sites:
    needs: [wait-for-packages, determine-environment]
    # Explicit condition needed because wait-for-packages uses if: always()
    if: ${{ always() && !cancelled() && !failure() }}
    uses: ./.github/workflows/action-publish-sites.yml
    secrets: inherit
    with:
      CONFIG_NAME: ${{ needs.determine-environment.outputs.environment }}
      COMMIT_SHA: ${{ needs.checkout-graduated.outputs.commit }}

  smoke-tests:
    needs: [publish-services, publish-sites, determine-environment]
    # Explicit condition needed because publish-services/publish-sites use if: always()
    if: ${{ always() && !cancelled() && !failure() }}
    uses: ./.github/workflows/action-smoke-tests.yml
    secrets: inherit
    with:
      CONFIG_NAME: ${{ needs.determine-environment.outputs.environment }}

  notify-success:
    needs: [smoke-tests, determine-environment]
    # Explicit condition needed because smoke-tests uses if: always()
    if: ${{ always() && !cancelled() && !failure() }}
    runs-on: ubuntu-latest
    steps:
      - name: Deployment successful
        run: |
          echo "‚úÖ Successfully deployed ${{ github.ref_name }} to ${{ needs.determine-environment.outputs.environment }}"
          echo "Tag: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"

  cleanup:
    needs: [smoke-tests, determine-environment]
    # Explicit condition needed because smoke-tests uses if: always()
    # Only cleanup test environments (prodtest)
    if: ${{ always() && !cancelled() && !failure() && needs.determine-environment.outputs.environment == 'prodtest' }}
    uses: ./.github/workflows/action-cleanup-old-packages.yml
    secrets: inherit
